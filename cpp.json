{
	"c++ codeforces": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"#define rep(i,n) for (ll i=0; i<(n); ++i)",
			"#define rrep(i, n) for (ll i=(n-1); i>=0; --i)",
			"#define sz(x) ll(x.size())",
			"#define debug(x) cerr<<#x<<\" = \"<<x<<'\\n'",
			"#define show(x) {for(auto i:x){cout<<i<<\" \";} cout<<endl;}",
			"#define shows(x) {for(auto y:x){show(y);}}",
			"#define isin(x,l,r) ((l)<=(x) && (x)<(r))",
			"#define NG {cout<<\"-1\"<<'\\n'; return 0;}",
			"#define OUT(x) {cout<<x<<'\\n'; return 0;}",
			"#define pcnt __builtin_popcountll",
			"#define prev previ",
			"using namespace std;",
			"using ll=long long;",
			"using pii=pair<int,int>;",
			"using pll=pair<ll,ll>;",
			"using tii=tuple<int, int, int>;",
			"using tll=tuple<ll, ll, ll>;",
			"template<typename T>bool chmin(T&x,const T&y) {if(x>y){x=y;return true;} else return false;}",
			"template<typename T>bool chmax(T&x,const T&y) {if(x<y){x=y;return true;} else return false;}",
			"const ll LINF = 2e18;",
			"const ll INF = 2e9;",
			"const ll MX = 200005;",
			"ll pow(ll a,ll n){ll x=1;for(;n;n/=2)n&1?x=x*a:0,a=a*a;return x;}",
			"ll pom(ll a,ll n,int m){a%=m;if(a==0){return 0;}ll x=1;for(;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}",
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}",
			"ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}",
			"",
			"\/\/codeforces",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(0);",
			"\t",
			"\t$2return 0;",
			"}",
			"",
		]
	},
	"c++ atcoder": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"#define rep(i,n) for (ll i=0; i<(n); ++i)",
			"#define rrep(i, n) for (ll i=(n-1); i>=0; --i)",
			"#define sz(x) ll(x.size())",
			"#define debug(x) cerr<<#x<<\" = \"<<x<<'\\n'",
			"#define show(x) {for(auto i:x){cout<<i<<\" \";} cout<<endl;}",
			"#define shows(x) {for(auto y:x){show(y);}}",
			"#define isin(x,l,r) ((l) <= (x) && (x) < (r))",
			"#define NG {cout<<\"-1\"<<'\\n'; return 0;}",
			"#define OUT(x) {cout<<x<<'\\n'; return 0;}",
			"#define pcnt __builtin_popcountll",
			"#define prev previ",
			"using namespace std;",
			"using namespace atcoder;",
			"using ll=long long;",
			"using pii=pair<int,int>;",
			"using pll=pair<ll,ll>;",
			"using tii=tuple<int, int, int>;",
			"using tll=tuple<ll, ll, ll>;",
			"template<typename T>bool chmin(T&x,const T&y) {if(x>y){x=y;return true;} else return false;}",
			"template<typename T>bool chmax(T&x,const T&y) {if(x<y){x=y;return true;} else return false;}",
			"const ll LINF = 2e18;",
			"const ll INF = 2e9;",
			"const ll MX = 200005;",
			"ll pow(ll a,ll n){ll x=1;for(;n;n/=2)n&1?x=x*a:0,a=a*a;return x;}",
			"ll pom(ll a,ll n,int m){a%=m;if(a==0){return 0;}ll x=1;for(;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}",
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}",
			"ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}",
			"",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(0);",
			"\t",
			"\t$2return 0;",
			"}",
			""
		]
	},
	"cin": {
		"prefix": "ci",
		"body": [
			"cin >> "
		]
	},
	"cout": {
		"prefix": "co",
		"body": [
			"cout << $1 << '\\n';"
		]
	},
	"cout << ans": {
		"prefix": "coa",
		"body": [
			"cout << ans << '\\n';"
		]
	},
	"cerr << \"-----\"": {
		"prefix": "celine",
		"body": [
			"cerr << \"--------\" << '\\n';"
		]
	},
	"cerr << \"here\"": {
		"prefix": "cehere",
		"body": [
			"cerr << \"here\" << '\\n';"
		]
	},
	"int": {
		"prefix": "int",
		"body": [
			"int",
		]
	},
	"int A;": {
		"prefix": "ia",
		"body": [
			"int A;",
			"cin >> A;",
			""
		]
	},
	"int B;": {
		"prefix": "ib",
		"body": [
			"int B;",
			"cin >> B;",
			""
		]
	},
	"int N;": {
		"prefix": "in",
		"body": [
			"int N;",
			"cin >> N;",
			""
		]
	},
	"int Q;": {
		"prefix": "iq",
		"body": [
			"int Q;",
			"cin >> Q;",
			""
		]
	},
	"int N, _;": {
		"prefix": "in2",
		"body": [
			"int N, $1;",
			"cin >> N >> $1;",
			""
		]
	},
	"int ;": {
		"prefix": "i1",
		"body": [
			"int $1;",
			"cin >> $1;",
			""
		]
	},
	"int , ;": {
		"prefix": "i2",
		"body": [
			"int $1, $2;",
			"cin >> $1 >> $2;",
			""
		]
	},
	"int N, M, L;": {
		"prefix": "in3",
		"body": [
			"int N, $1, $2;",
			"cin >> N >> $1 >> $2;",
			""
		]
	},
	"int , ,;": {
		"prefix": "i3",
		"body": [
			"int $1, $2, $3;",
			"cin >> $1 >> $2 >> $3;",
			""
		]
	},
	"int , , , ;": {
		"prefix": "i4",
		"body": [
			"int $1, $2, $3, $4;",
			"cin >> $1 >> $2 >> $3 >> $4;",
			""
		]
	},
	"int , , , , ;": {
		"prefix": "i5",
		"body": [
			"int $1, $2, $3, $4, $5;",
			"cin >> $1 >> $2 >> $3 >> $4 >> $5;",
			""
		]
	},
	"int A, B;": {
		"prefix": "iab",
		"body": [
			"int A, B;",
			"cin >> A >> B;",
			""
		]
	},
	"int A, B, C;": {
		"prefix": "iabc",
		"body": [
			"int A, B, C;",
			"cin >> A >> B >> C;",
			""
		]
	},
	"int N, M;": {
		"prefix": "inm",
		"body": [
			"int N, M;",
			"cin >> N >> M;",
			""
		]
	},
	"int N, Q;": {
		"prefix": "inq",
		"body": [
			"int N, Q;",
			"cin >> N >> Q;",
			""
		]
	},
	"int H, W;": {
		"prefix": "ihw",
		"body": [
			"int H, W;",
			"cin >> H >> W;",
			""
		]
	},
	"int X;": {
		"prefix": "ix",
		"body": [
			"int X;",
			"cin >> X;",
			""
		]
	},
	"int X, Y;": {
		"prefix": "ixy",
		"body": [
			"int X, Y;",
			"cin >> X >> Y;",
			""
		]
	},
	"int X, Y, Z;": {
		"prefix": "ixyz",
		"body": [
			"int X, Y, Z;",
			"cin >> X >> Y >> Z;",
			""
		]
	},
	"ll A;": {
		"prefix": "la",
		"body": [
			"ll A;",
			"cin >> A;",
			""
		]
	},
	"ll B;": {
		"prefix": "lb",
		"body": [
			"ll B;",
			"cin >> B;",
			""
		]
	},
	"ll N;": {
		"prefix": "ln",
		"body": [
			"ll N;",
			"cin >> N;",
			""
		]
	},
	"ll M;": {
		"prefix": "lm",
		"body": [
			"ll M;",
			"cin >> M;",
			""
		]
	},
	"ll Q;": {
		"prefix": "lq",
		"body": [
			"ll Q;",
			"cin >> Q;",
			""
		]
	},
	"ll N, _;": {
		"prefix": "ln2",
		"body": [
			"ll N, $1;",
			"cin >> N >> $1;",
			""
		]
	},
	"double ;": {
		"prefix": "d1",
		"body": [
			"double $1;",
			"cin >> $1;",
			""
		]
	},
	"double a, b;": {
		"prefix": "d2",
		"body": [
			"double $1, $2;",
			"cin >> $1 >> $2;",
			""
		]
	},
	"ll ;": {
		"prefix": "l1",
		"body": [
			"ll $1;",
			"cin >> $1;",
			""
		]
	},
	"ll , ;": {
		"prefix": "l2",
		"body": [
			"ll $1, $2;",
			"cin >> $1 >> $2;",
			""
		]
	},
	"ll N, M, L;": {
		"prefix": "ln3",
		"body": [
			"ll N, $1, $2;",
			"cin >> N >> $1 >> $2;",
			""
		]
	},
	"ll N, M, L, K;": {
		"prefix": "ln4",
		"body": [
			"ll N, $1, $2, $3;",
			"cin >> N >> $1 >> $2 >> $3;",
			""
		]
	},
	"ll , ,;": {
		"prefix": "l3",
		"body": [
			"ll $1, $2, $3;",
			"cin >> $1 >> $2 >> $3;",
			""
		]
	},
	"ll , , , ;": {
		"prefix": "l4",
		"body": [
			"ll $1, $2, $3, $4;",
			"cin >> $1 >> $2 >> $3 >> $4;",
			""
		]
	},
	"ll , , , , ;": {
		"prefix": "l5",
		"body": [
			"ll $1, $2, $3, $4, $5;",
			"cin >> $1 >> $2 >> $3 >> $4 >> $5;",
			""
		]
	},
	"ll A, B;": {
		"prefix": "lab",
		"body": [
			"ll A, B;",
			"cin >> A >> B;",
			""
		]
	},
	"ll A, B, C;": {
		"prefix": "labc",
		"body": [
			"ll A, B, C;",
			"cin >> A >> B >> C;",
			""
		]
	},
	"ll N, M;": {
		"prefix": "lnm",
		"body": [
			"ll N, M;",
			"cin >> N >> M;",
			""
		]
	},
	"ll H, W;": {
		"prefix": "lhw",
		"body": [
			"ll H, W;",
			"cin >> H >> W;",
			""
		]
	},
	"ll X;": {
		"prefix": "lx",
		"body": [
			"ll X;",
			"cin >> X;",
			""
		]
	},
	"ll X, Y;": {
		"prefix": "lxy",
		"body": [
			"ll X, Y;",
			"cin >> X >> Y;",
			""
		]
	},
	"ll X, Y, Z;": {
		"prefix": "lxyz",
		"body": [
			"ll X, Y, Z;",
			"cin >> X >> Y >> Z;",
			""
		]
	},
	"char c;": {
		"prefix": "cc",
		"body": [
			"char $1c;",
			"cin >> $1c;",
			""
		]
	},
	"string S;": {
		"prefix": "ss",
		"body": [
			"string $1S;",
			"cin >> $1S;",
			""
		]
	},
	"string T;": {
		"prefix": "st",
		"body": [
			"string $1T;",
			"cin >> $1T;",
			""
		]
	},
	"string S, T;": {
		"prefix": "sst",
		"body": [
			"string $1S, $2T;",
			"cin >> $1S >> $2T;",
			""
		]
	},
	"vector<>": {
		"prefix": "ve",
		"body": [
			"vector<$1> "
		]
	},
	"vector<int>": {
		"prefix": "veint",
		"body": [
			"vector<int> "
		]
	},
	"vector<double>": {
		"prefix": "vedouble",
		"body": [
			"vector<double> "
		]
	},
	"vector<ll>": {
		"prefix": "vel",
		"body": [
			"vector<ll> "
		]
	},
	"vector<tuple<ll, ll, ll>>": {
		"prefix": "vet",
		"body": [
			"vector<tuple<$2ll, $2ll, $2ll>> $1;"
		]
	},
	"tuple<ll, ll, ll>": {
		"prefix": "tup",
		"body": [
			"tuple<$1ll, $1ll, $1ll>"
		]
	},
	"vector<int> A(N)": {
		"prefix": "veia",
		"body": [
			"vector<$1int> $2A($3N);",
			"rep(i, $3N) cin >> $2A[i];",
			""
		]
	},
	"ll N; vector<ll> A(N)": {
		"prefix": "lnvea",
		"body": [
			"ll $1N;",
			"cin >> $1N;",
			"vector<$2ll> $3A($1N);",
			"rep(i, $1N) cin >> $3A[i];",
			""
		]
	},
	"vector<ll> A(N)": {
		"prefix": "vea",
		"body": [
			"vector<ll> $1A($2N);",
			"rep(i, $2N) cin >> $1A[i];",
			""
		]
	},
	"vector<ll> B(N)": {
		"prefix": "veb",
		"body": [
			"vector<ll> $1B($2N);",
			"rep(i, $2N) cin >> $1B[i];",
			""
		]
	},
	"vector<ll> A, B(N)": {
		"prefix": "veab",
		"body": [
			"vector<ll> $1A($2N);",
			"rep(i, $2N) cin >> $1A[i];",
			"vector<ll> $3B($4N);",
			"rep(i, $4N) cin >> $3B[i];",
			""
		]
	},
	"vector<pll> A(N)": {
		"prefix": "vepll",
		"body": [
			"vector<pll> $1A($2N);",
			"for (auto& [a, b] : $1A) {",
			"\tcin >> a >> b;",
			"}",
			""
		]
	},
	"priority_queue<ll> que;": {
		"prefix": "pq",
		"body": [
			"priority_queue<$1ll> que;"
		]
	},
	"priority_queue greater": {
		"prefix": "pq greater",
		"body": "priority_queue<$1ll, vector<$1ll>, greater<$1ll>> que;",
		"description": "小さいものから出てくる"
	},
	"rep(i, N)": {
		"prefix": "re",
		"body": [
			"rep(i, $1N) "
		]
	},
	"rrep(i, N)": {
		"prefix": "rre",
		"body": [
			"rrep(i, $1N) "
		]
	},
	"rep(i, M)": {
		"prefix": "rem",
		"body": [
			"rep(i, $1M) "
		]
	},
	"rep(i, Q)": {
		"prefix": "req",
		"body": [
			"rep(i, Q) {",
			"\t$1",
			"}"
		]
	},
	"rep(j, N)": {
		"prefix": "rej",
		"body": [
			"rep(j, $1N) "
		]
	},
	"rep(i, N) rep(j, N)": {
		"prefix": "reij",
		"body": [
			"rep(i, $1N) rep(j, $1N) "
		]
	},
	"rep(k, N)": {
		"prefix": "rek",
		"body": [
			"rep(k, $1N) "
		]
	},
	"for (ll i = 0;...": {
		"prefix": "fi",
		"body": [
			"for (ll $3i = $1; $3i < $2N; $3i++) {",
			"\t",
			"}"
		]
	},
	"for (ll j = 0;...": {
		"prefix": "fj",
		"body": [
			"for (ll j = $1; j < $2N; j++) {",
			"\t",
			"}"
		]
	},
	"for (ll k = 0;...": {
		"prefix": "fk",
		"body": [
			"for (ll k = $1; k < $2N; k++) {",
			"\t",
			"}"
		]
	},
	"for (ll i = N;...": {
		"prefix": "fi-",
		"body": [
			"for (ll $2i = $1N-1; $2i >= 0; $2i--) {",
			"\t",
			"}"
		]
	},
	"for (ll j = N;...": {
		"prefix": "fj-",
		"body": [
			"for (ll j = $1N-1; j >= 0; j--) {",
			"\t",
			"}"
		]
	},
	"for (ll k = N;...": {
		"prefix": "fk-",
		"body": [
			"for (ll k = $1N-1; k >= 0; k--) {",
			"\t",
			"}"
		]
	},
	"for (ll l = 0;...": {
		"prefix": "fl",
		"body": [
			"for (ll l = $1; l < $2N; l++) {",
			"\t",
			"}"
		]
	},
	"for (ll m = 0;...": {
		"prefix": "fm",
		"body": [
			"for (ll m = $1; m < $2N; m++) {",
			"\t",
			"}"
		]
	},
	"for (ll bit = 0 ...": {
		"prefix": "bit",
		"body": "for (ll bit = 0; bit < (1<<$1N); bit++) {\n\tfor (ll $2i = 0; $2i < $1N; $2i++) {\n\t\tif ((bit>>$2i) & 1) {\n\t\t\t$3\n\t\t}\n\t}\n}"
	},
	"rotate vector": {
		"prefix": "rotatevector",
		"body": [
			"rotate($1A.begin(), $1A.begin() + 1, $1A.end());",
		]
	},
	"sort()": {
		"prefix": "sort",
		"body": [
			"sort($1.begin(), $1.end());"
		]
	},
	"sort(greater<ll>())": {
		"prefix": "sortgreater",
		"body": [
			"sort($1.begin(), $1.end(), greater<ll>());"
		]
	},
	"sort(lambda)": {
		"prefix": "sortlambda",
		"body": [
			"sort($1.begin(), $1.end(), [&]($2ll $3a, $2ll $4b) {",
				"\treturn $5 > $6;",
			"});"
		]
	},
	"lower_bound()": {
		"prefix": "lower_bound()",
		"body": [
			"lower_bound($1.begin(), $1.end(), $2);"
		]
	},
	"upper_bound()": {
		"prefix": "upper_bound()",
		"body": [
			"upper_bound($1.begin(), $1.end(), $2);"
		]
	},
	".begin(), .end()": {
		"prefix": ".be",
		"body": [
			"$1.begin(), $1.end()"
		]
	},
	".rbegin()": {
		"prefix": ".rbe",
		"body": [
			"$1.rbegin(), $1.rend()"
		]
	},
	".empty()": {
		"prefix": ".em",
		"body": [
			".empty()"
		]
	},
	".push()": {
		"prefix": ".pu",
		"body": [
			".push($1);"
		]
	},
	".pop()": {
		"prefix": ".po",
		"body": [
			".pop();"
		]
	},
	".clear()": {
		"prefix": ".cl",
		"body": [
			".clear();"
		]
	},
	".push_back()": {
		"prefix": ".pub",
		"body": [
			".push_back($2);"
		]
	},
	".pop_front()": {
		"prefix": ".pof",
		"body": [
			".pop_front();"
		]
	},
	".pop_back()": {
		"prefix": ".pob",
		"body": [
			".pop_back();"
		]
	},
	".emplace()": {
		"prefix": ".emp",
		"body": [
			".emplace($1);"
		]
	},
	".emplace_front()": {
		"prefix": ".emf",
		"body": [
			".emplace_front($1);"
		]
	},
	".emplace_back()": {
		"prefix": ".emb",
		"body": [
			".emplace_back($1);"
		]
	},
	".push_front()": {
		"prefix": ".puf",
		"body": [
			".push_front($1);"
		]
	},
	".top()": {
		"prefix": ".to",
		"body": [
			".top()"
		]
	},
	".first": {
		"prefix": ".fi",
		"body": [
			".first"
		]
	},
	".second": {
		"prefix": ".se",
		"body": [
			".second"
		]
	},
	"bool": {
		"prefix": "bl",
		"body": [
			"bool bl = $1;",
			"cout << (bl ? \"$2Yes\" : \"$3No\") << '\\n';"
		]
	},
	"dx, dy": {
		"prefix": "dxdy",
		"body": [
			"const ll dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};",
			"const ll dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};",
			""
		]
	},
	"makeDivisors": {
		"prefix": "makediv",
		"body": [
			"vector<ll> makeDivisors(ll n) {",
			"\tvector<ll> ret;",
			"\tfor(ll i = 1; i * i <= n; i++) {",
			"\t\tif(n%i == 0) {",
			"\t\t\tret.push_back(i);",
			"\t\t\tif(i*i != n) ret.push_back(n/i);",
			"\t\t}",
			"\t}",
			"\tsort(ret.begin(), ret.end());",
			"\treturn ret;",
			"}"
		],
		"description": "約数列挙"
	},
	"1-indexed": {
		"prefix": "1i",
		"body": [
			"  // 1-indexed"
		]
	},
	"0-indexed": {
		"prefix": "0i",
		"body": [
			"  // 0-indexed"
		]
	},
	"graph": {
		"prefix": "graph",
		"body": [
			"vector<ll> graph[$1N];"
		]
	},
	"tree": {
		"prefix": "tree",
		"body": [
			"vector<ll> graph[$1N]; // 0-indexed",
			"rep(i, $2N-1) {",
			"\tll a, b;",
			"\tcin >> a >> b;",
			"\t--a; --b;",
			"\tgraph[a].push_back(b);",
			"\tgraph[b].push_back(a); $3// Directed Graph?",
			"}"
		]
	},
	"order": {
		"prefix": "order",
		"body": [
			"ll root = 0;",
			"vector<ll> parent(N, -1);",
			"vector<ll> order;",
			"stack<ll> stk; // llかどうかに注意",
			"stk.push(root);",
			"while (!stk.empty()) {",
			"\tll cur = stk.top(); stk.pop();",
			"\torder.push_back(cur);",
			"\tfor (ll next : graph[cur]) {",
			"\t\tif (next == parent[cur]) continue;",
			"\t\tparent[next] = cur;",
			"\t\tstk.push(next);",
			"\t}",
			"}"
		]
	},
	"binary search": {
		"prefix": "ok",
		"body": [
			"ll ok = 0; ll ng = $2;",
			"while (abs(ng - ok) > 1) {",
			"\tll mid = (ok + ng) / 2;",
			"\t(check(mid) ? ok : ng) = mid;",
			"}"
		]
	},
	"mint": {
		"prefix": "mint",
		"body": [
			"const int MOD =$1 998244353;",
			"struct mint {",
			"\tll x;",
			"\tmint(ll x=0):x((x%MOD+MOD)%MOD){}",
			"\tmint operator-() const { return mint(-x);}",
			"\tmint& operator+=(const mint a) {",
			"\t\tif ((x += a.x) >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator-=(const mint a) {",
			"\t\tif ((x += MOD-a.x) >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}",
			"\tmint operator+(const mint a) const { return mint(*this) += a;}",
			"\tmint operator-(const mint a) const { return mint(*this) -= a;}",
			"\tmint operator*(const mint a) const { return mint(*this) *= a;}",
			"\tmint pow(ll t) const {",
			"\t\tif (!t) return 1;",
			"\t\tmint a = pow(t>>1);",
			"\t\ta *= a;",
			"\t\tif (t&1) a *= *this;",
			"\t\treturn a;",
			"\t}",
			"\t// for prime MOD",
			"\tll val() const { return x;}",
			"\tmint inv() const { return pow(MOD-2);}",
			"\tmint& operator/=(const mint a) { return *this *= a.inv();}",
			"\tmint operator/(const mint a) const { return mint(*this) /= a;}",
			"};",
			"istream& operator>>(istream& is, mint& a) { return is >> a.x;}",
			"ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}",
			"// combination MOD prime",
			"struct combination {",
			"\tvector<mint> fact, ifact;",
			"\tcombination(int n):fact(n+1),ifact(n+1) {",
			"\t\tassert(n < MOD);",
			"\t\tfact[0] = 1;",
			"\t\tfor (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
			"\t\tifact[n] = fact[n].inv();",
			"\t\tfor (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
			"\t}",
			"\tmint operator()(int n, int k) {",
			"\t\tif (k < 0 || k > n) return 0;",
			"\t\treturn fact[n]*ifact[k]*ifact[n-k];",
			"\t}",
			"\tmint p(int n, int k) {",
			"\t\tif (k < 0 || k > n) return 0;",
			"\t\treturn fact[n]*ifact[n-k];",
			"\t}",
			"}$2; //comb(10000007); // ← limit is MOD-1",
			"// comb(5, 2) → 10, comb.p(5, 2) → 20",
			"// comb.fact[4] → 24, mint(2).pow(3) → 8"
		]
	},
	"dx": {
		"prefix": "dx",
		"body": "const ll dx[4] = {1, 0, -1, 0};"
	},
	"prime factorize": {
		"prefix": "primefac",
		"body": "vector<pll> primeFactorize(ll n) {\n\tvector<pll> res;\n\tfor (ll i = 2; i*i <= n; ++i) {\n\t\tif (n%i) continue;\n\t\tres.emplace_back(i,0);\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tres.back().second++;\n\t\t}\n\t}\n\tif (n != 1) res.emplace_back(n,1);\n\treturn res;\n}",
		"description": "nの素因数分解"
	},
	"double": {
		"prefix": "dou",
		"body": "double "
	},
	"PI": {
		"prefix": "PI",
		"body": "double PI = acos(-1);"
	},
	"cout << \"Yes\" << endl": {
		"prefix": "Yes",
		"body": "cout << \"Yes\" << '\\n';\n$1return 0;"
	},
	"cout << \"No\" << endl": {
		"prefix": "Nono",
		"body": "cout << \"No\" << '\\n';\n$1return 0;"
	},
	"popcount": {
		"prefix": "popc",
		"body": "__builtin_popcountll($1)"
	},
	"continue;": {
		"prefix": "cont",
		"body": "continue;"
	},
	"lcm": {
		"prefix": "lcm",
		"body": "ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}"
	},
	"isPrime": {
		"prefix": "isprime",
		"body": "ll U = 1e6;\nvector<bool> isPrime(U, 0);\nisPrime[2] = 1;\nfor (ll i = 3; i < U; i=i+2) {\n\tisPrime[i] = 1;\n}\nfor (int p = 3; p * p <= U; p=p+2) {\n\tif (isPrime[p]) {\n\t\tfor (ll i = p*p; i < U; i=i+2*p) {\n\t\t\tisPrime[i] = 0;\n\t\t}\n\t}\n}",
		"description": "素数判定"
	},
	"factorial": {
		"prefix": "fact",
		"body": "vector<ll> fact(N+1);\nfact[1] = 1;\nfor (ll i = 2; i < N+1; i++) {\n\tfact[i] = i * fact[i-1];\n}"
	},
	"gcd": {
		"prefix": "gcd",
		"body": "ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}"
	},
	"res": {
		"prefix": "res",
		"body": "ll res = $1;\nreturn res;"
	},
	"oklambda": {
		"prefix": "oklam",
		"body": "ll ok = 0; ll ng = $1;\nwhile (abs(ng - ok) > 1) {\n\tll mid = (ok + ng) / 2;\n\tbool bl = [&] {\n\t\treturn $2;\n\t}();\n\t(bl ? ok : ng) = mid;\n}"
	},
	"rehw": {
		"prefix": "rehw",
		"body": "rep(i, H) rep(j, W) "
	},
	"vevea": {
		"prefix": "vevea",
		"body": [
			"vector<vector<$1ll>> $2A($3H, vector<$1ll>($4W));",
			"rep(i, $3H) rep(j, $4W) cin >> $2A[i][j];\n",
		]
	},
	"vevell": {
		"prefix": "vevell",
		"body": [
			"vector<vector<$1ll>> $2A($3N, vector<$1ll>($4N));",
		]
	},
	"que": {
		"prefix": "que",
		"body": "queue<$1ll> $2que;"
	},
	"bfsgrid": {
		"prefix": "bfsgrid",
		"body": ["vector<vector<ll>> dist(H, vector<ll> (W, INF));",
		"queue<pii> que;",
		"auto update = [&] (ll i, ll j, ll d) {",
		"\tif (dist[i][j] != INF) return;",
		"\tdist[i][j] = d;",
		"\tque.emplace(i, j);",
		"};",
		"update(si, sj, 0);",
		"",
		"while (!que.empty()) {",
		"\tauto [ci, cj] = que.front(); que.pop();",
		"\trep(dir, 4) {",
		"\t\tll ni = ci + dy[dir];",
		"\t\tll nj = cj + dx[dir];",
		"\t\tif (!(isin(ni, 0, H) && isin(nj, 0, W))) continue;",
		"\t\tif (S[ni][nj] == '#' || dist[ni][nj] != INF) continue;",
		"\t\tupdate(ni, nj, dist[ci][cj] + 1);",
		"\t}",
		"}",]
	},
	"Sieve": {
		"prefix": "sieve",
		"body": [
			"struct Sieve {\n\tint n;\n\tvector<int> f, primes;\n\tSieve(int n=1):n(n), f(n+1) {\n\t\tf[0] = f[1] = -1;\n\t\tfor (ll i = 2; i <= n; ++i) {\n\t\t\tif (f[i]) continue;\n\t\t\tprimes.push_back(i);\n\t\t\tf[i] = i;\n\t\t\tfor (ll j = i*i; j <= n; j += i) {\n\t\t\t\tif (!f[j]) f[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tbool isPrime(int x) { return f[x] == x;}\n\tvector<int> factorList(int x) {\n\t\tvector<int> res;\n\t\twhile (x != 1) {\n\t\t\tres.push_back(f[x]);\n\t\t\tx /= f[x];\n\t\t}\n\t\treturn res;\n\t}\n\tvector<pii> factor(int x) {\n\t\tvector<int> fl = factorList(x);\n\t\tif (fl.size() == 0) return {};\n\t\tvector<pii> res(1, pii(fl[0], 0));\n\t\tfor (int p : fl) {\n\t\t\tif (res.back().first == p) {\n\t\t\t\tres.back().second++;\n\t\t\t} else {\n\t\t\t\tres.emplace_back(p, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvector<pair<ll,int>> factor(ll x) {\n\t\tvector<pair<ll,int>> res;\n\t\tfor (int p : primes) {\n\t\t\tint y = 0;\n\t\t\twhile (x%p == 0) x /= p, ++y;\n\t\t\tif (y != 0) res.emplace_back(p,y);\n\t\t}\n\t\tif (x != 1) res.emplace_back(x,1);\n\t\treturn res;\n\t}\n};",
			"// Sieve sieve(1e6);\n// auto fl = sieve.factorList(x); でxの因数分解の配列\n// auto f = sieve.factor(x); でxの因数分解、因数と指数のpairの配列がfに入る\n// sieve.primes\t\t   の配列(sieve(x) のxを含む)"
		]
	},
	"printf": {
		"prefix": "printf",
		"body": "printf(\"%.10$1f\\n\", $2ans); // cin に注意"
	},
	"printfd": {
		"prefix": "printfd",
		"body": "printf(\"%$1d\\n\", $2ans); // cin に注意"
	},
	"map": {
		"prefix": "map",
		"body": "map<$1, ll> mp;\n"
	},
	"cout2": {
		"prefix": "co2",
		"body": "cout << $1 << ' ' << $2 << '\\n';"
	},
	"cerr": {
		"prefix": "ce",
		"body": "cerr << $1 << '\\n';"
	},
	"cerr2": {
		"prefix": "ce2",
		"body": "cerr << $1 << \" \" << $2 << '\\n';"
	},
	"cout3": {
		"prefix": "co3",
		"body": "cout << $1 << ' ' << $2 << ' ' << $3 << '\\n';"
	},
	"cerr3": {
		"prefix": "ce3",
		"body": "cerr << $1 << \" \" << $2 << \" \" << $3 << '\\n';"
	},
	"reverse": {
		"prefix": "reverse",
		"body": "reverse($1.begin(), $1.end());"
	},
	"UnionFind": {
		"prefix": "unionfind",
		"body": [
			"struct UnionFind {",
			"\tvector<ll> d;",
			"\tll n, groups;",
			"\tUnionFind(ll n): d(n,-1), n(n), groups(n) {}",
			"\tll root(ll x) {",
			"\t\tif (d[x] < 0) return x;",
			"\t\treturn d[x] = root(d[x]);",
			"\t}",
			"\tbool unite(ll x, ll y) {",
			"\t\tx = root(x); y = root(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (d[x] > d[y]) swap(x,y);",
			"\t\td[x] += d[y];",
			"\t\td[y] = x;",
			"\t\tgroups--;",
			"\t\treturn true;",
			"\t}",
			"\tbool same(ll x, ll y) { return root(x) == root(y); }",
			"\tll size(ll x) { return -d[root(x)]; }",
			"};  // UnionFind uf(N);",
		],
	},
	".insert()": {
		"prefix": ".ins",
		"body": ".insert($1)"
	},
	".lower_bound()": {
		"prefix": ".lower_bound",
		"body": ".lower_bound($1)"
	},
	".upper_bound()": {
		"prefix": ".upper_bound",
		"body": ".upper_bound($1)"
	},
	"ng": {
		"prefix": "ng",
		"body": "cout << $1-1 << '\\n';\nreturn 0;"
	},
	"endl": {
		"prefix": "endl",
		"body": "cout << '\\n';"
	},
	"ceendl": {
		"prefix": "ceendl",
		"body": "cerr << '\\n';"
	},
	"return 0;": {
		"prefix": "r0",
		"body": "return 0;"
	},
	"isPalindrome()": {
		"prefix": "ispal",
		"body": "bool isPalindrome(string s) {\n\tstring t = s;\n\treverse(t.begin(), t.end());\n\treturn s == t;\n}"
	},
	"vector<string>": {
		"prefix": "ves",
		"body": "vector<string> $1S($2N);\nrep(i, $2N) cin >> $1S[i];\n"
	},
	"int INF": {
		"prefix": "INFint",
		"body": "const int INF = 2e9;"
	},
	"dijkstra": {
		"prefix": "dij",
		"body": [
			"struct Edge {",
			"\tll to, co;",
			"\tEdge(ll to, ll co) : to(to), co(co) {}",
			"};",
			"",
			"struct Data {",
			"\tll d; // distance from start",
			"\tll v; // vertex",
			"\tData(ll d, ll v) : d(d), v(v) {}",
			"\tbool operator<(const Data& a) const {",
			"\t\treturn d > a.d;",
			"\t}",
			"};",
			"",
			"vector<Edge> graph$2[MX];",
			"",
			"vector<ll> dijkstra(ll N, ll start) {",
			"\tvector<ll> dist(N, LINF);",
			"\tpriority_queue<Data> que;",
			"\tauto push = [&] (ll d, ll v) {",
			"\t\tif (dist[v] <= d) return;",
			"\t\tdist[v] = d;",
			"\t\tque.emplace(d, v);",
			"\t};",
			"\tpush(0, start);",
			"\twhile(!que.empty()) {",
			"\t\tData data1 = que.top(); que.pop();",
			"\t\tll v = data1.v;",
			"\t\tll d = data1.d;",
			"\t\tif (dist[v] != d) continue;",
			"\t\tfor (Edge e : graph[v]) {",
			"\t\t\tpush(d+e.co, e.to);",
			"\t\t}",
			"\t}",
			"\treturn dist;",
			"}",
		]
	},
	"bellmanford": {
		"prefix": "bellmanford",
		"body": [
			"struct Edge {",
			"\tll pre, ne, cost;",
			"\tEdge(ll pre, ll ne, ll cost): pre(pre), ne(ne), cost(cost) {}",
			"};",
			"",
			"vector<Edge> edges;",
			"",
			"ll bellmanford(ll N, ll start, ll goal) {",
			"\tvector<ll> dist(N, LINF);",
			"\tdist[start] = 0;",
			"\trep(i, N) {",
			"\t\tfor (auto [pre, ne, cost] : edges) {",
			"\t\t\tif (dist[pre] != LINF && chmin(dist[ne], dist[pre] + cost)) {",
			"\t\t\t\tif (i == N-1 && ne == goal) return -1;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn dist[goal];",
			"}",
		],
	},
	"BIT Fenwick Tree": {
		"prefix": "BITfen",
		"body": "template<typename T>\nstruct BIT {\n\tll n;\n\tvector<T> d;\n\tBIT(int n=0):n(n), d(n+1) {}\n\tvoid add(int i, T x=1) {\n\t\tfor (i++; i <= n; i += i&-i) {\n\t\t\t//i&-iで最下位bitを足している\n\t\t\td[i] += x;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT x = 0;\n\t\tfor (i++; i; i -= i&-i) {\n\t\t\tx += d[i];\n\t\t}\n\t\treturn x;\n\t}\n\tT semiopenSum(int l, int r) {\n\t\t// [l,r)の半開区間\n\t\treturn sum(r-1) - sum(l-1);\n\t}\n};  // BIT<int> bit(N);"
	},
	".begin()": {
		"prefix": ".beg",
		"body": ".begin()"
	},
	".end()": {
		"prefix": ".end",
		"body": ".end()"
	},
	"accumulate()": {
		"prefix": "accumulate",
		"body": "accumulate($1.begin(), $1.end(), 0ll)",
	},
	"mod2": {
		"prefix": "mod2",
		"body": "1000'000'007",
	},
	"stoll9": {
		"prefix": "stoll9",
		"body": "ll stoll9(string s) {\n\t// 10 ^ 9倍した整数を返す\n\tint digit = 0;\n\tfor (int i = sz(s)-1; i >= 0; i--) {\n\t\tif (s[i] == '.') {\n\t\t\ts.replace(i, 1, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tdigit++;\n\t\tif (i == 0) digit = 0;\n\t}\n\tll x = stoll(s);\n\trep(i, 9-digit) x *= 10;\n\treturn x;\n}",
		"description": "stringから10 ^ 9倍した整数を返す"
	},
	"stoi()": {
		"prefix": "stoi",
		"body": "stoi($1)",
		"description": ""
	},
	"mat mul": {
		"prefix": "matmul",
		"body": "using mat = vector<vector<int>>;\n\nmat mul(mat &A, mat &B) {\n\tmat C(A.size(), vector<int> (B[0].size()));\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tfor (int k = 0; k < B.size(); k++) {\n\t\t\tfor (int j = 0; j < B[0].size(); j++) {\n\t\t\t\tC[i][j] += A[i][k] * B[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn C;\n}",
		"description": "行列の掛け算？"
	},
	"for (ll i = 1 ...)": {
		"prefix": "fi1",
		"body": "for (ll $2i = 1; $2i <= $1N; $2i++) {\n\t$3\n}"
	},
	"for (ll j = 1 ...)": {
		"prefix": "fj1",
		"body": "for (ll $2j = 1; $2j <= $1N; $2j++) {\n\t$3\n}"
	},
	"for (ll k = 1 ...)": {
		"prefix": "fk1",
		"body": "for (ll $2k = 1; $2k <= $1N; $2k++) {\n\t$3\n}"
	},
	"struct constructor": {
		"prefix": "structconst",
		"body": "struct $1 {\n\t$2ll $3, $4;\n\t$1($2ll $3, $2ll $4): $3($3), $4($4) {}\n};"
	},
	"LCA": {
		"prefix": "lca",
		"body": [
			"class LCA {",
			"\t// 要改善",
			"\tprivate:",
			"\tll root;",
			"\tll k; // n <= 2^kとなる最小のk",
			"\tvector<vector<ll>> parentPow; // parentPow[i][j]　要素jの2^i番目の親",
			"\tvector<ll> depth;",
			"\t",
			"\tpublic:",
			"\tLCA(const vector<vector<ll>>& graph, ll _root=0){",
			"\t\tll n = graph.size();",
			"\t\troot = _root;",
			"\t\tk = 1;",
			"\t\tll power = 2;",
			"\t\twhile (power < n){",
			"\t\t\tpower <<= 1;",
			"\t\t\tk++;",
			"\t\t}",
			"\t\tparentPow = vector<vector<ll>>(k+1, vector<ll>(n, -1));",
			"\t\tdepth.resize(n);",
			"\t\tfunction<void(ll, ll)> _dfs = [&](ll v, ll p){",
			"\t\t\tparentPow[0][v] = p;",
			"\t\t\tfor (auto nv: graph[v]){",
			"\t\t\t\tif (nv == p) continue;",
			"\t\t\t\tdepth[nv] = depth[v] + 1;",
			"\t\t\t\t_dfs(nv, v); ",
			"\t\t\t}",
			"\t\t};",
			"\t\t_dfs(root, -1);",
			"\t\t// ダブリング",
			"\t\tfor (ll i = 0; i < k; i++){",
			"\t\t\tfor (ll j = 0; j < n; j++){",
			"\t\t\t\tif (parentPow[i][j] == -1) continue;",
			"\t\t\t\tparentPow[i+1][j] = parentPow[i][parentPow[i][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t/// get LCA",
			"\tll get(ll u, ll v){",
			"\t\tif (depth[u] < depth[v]) swap(u, v); // uを深く",
			"\t\tif (depth[u] != depth[v]){",
			"\t\t\tll d = depth[u] - depth[v];",
			"\t\t\tfor (ll i = 0; i < k; i++) if ((d>>i) & 1) u = parentPow[i][u];",
			"\t\t}",
			"\t\tif (u == v) return u;",
			"\t\tfor (ll i = k; i >= 0; i--){",
			"\t\t\tif (parentPow[i][u] != parentPow[i][v]){",
			"\t\t\t\tu = parentPow[i][u], v = parentPow[i][v];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn parentPow[0][u];",
			"\t}",
			"\tll get_distance(const ll u, const ll v){",
			"\t\tll lca = get(u, v);",
			"\t\treturn depth[u] + depth[v] - 2*depth[lca];",
			"\t}",
			"};",
		],
	},
	"struct normal": {
		"prefix": "structnormal",
		"body": "struct $1 {\n\t$2\n};",
	},
	"structconst4": {
		"prefix": "structconst4",
		"body": "struct $1 {\n\t$2ll $3, $4, $5, $6;\n\t$1($2ll $3, $2ll $4, $2ll $5, $2ll $6): $3($3), $4($4), $5($5), $6($6) {}\n};",
		"description": ""
	},
	"struct operator": {
		"prefix": "structoperator",
		"body": [
			"struct Data {",
			"\tll $1, $2;",
			"\tData(ll $1, ll $2) : $1($1), $2($2) {}",
			"\tbool operator<(const Data& a) const {",
			"\t\tif ($1 == a.$1) return $2 < a.$2;",
			"\t\treturn $1 < a.$1;",
			"\t}",
			"};",
		],
	},
	"deq": {
		"prefix": "deq",
		"body": "deque<$1ll> dq",
	},
	"memset": {
		"prefix": "memset",
		"body": "memset($1, $2, sizeof($1));"
	},
	"vemint": {
		"prefix": "vemi",
		"body": "vector<mint> "
	},
	"fill": {
		"prefix": "fill",
		"body": "fill($1.begin(), $1.end(), $2);"
	},
	"for (ll a : A)": {
		"prefix": "fa",
		"body": "for (ll $1a : $2A) {\n\t$3\n}"
	},
	"for (ll x : A)": {
		"prefix": "fx",
		"body": "for (ll $1x : $2A) {\n\t$3\n}"
	},
	"for (auto p : A)": {
		"prefix": "fautop",
		"body": "for (auto $1p : $2A) {\n\t$3\n}"
	},
	"for (char c : S)": {
		"prefix": "fc",
		"body": "for (char $1c : $2S) {\n\t$3\n}"
	},
	"set": {
		"prefix": "set",
		"body": "set<$1ll> ",
	},
	"multiset": {
		"prefix": "multiset",
		"body": "multiset<$1ll> ",
	},
	"eraseunique": {
		"prefix": "eruni",
		"body": "$1.erase(unique($1.begin(), $1.end()), $1.end());",
		"description": "重複したものを消す"
	},
	".front()": {
		"prefix": ".fro",
		"body": ".front()",
	},
	".back()": {
		"prefix": ".ba",
		"body": ".back()",
	},
	"for (auto p : X)": {
		"prefix": "fp",
		"body": "for (auto p : $1) {\n\t$2\n}",
	},
	"numberOfDigits": {
		"prefix": "digits",
		"body": "ll numberOfDigits(ll x) {\n\t// 自然数の桁数を返す\n\tll res = 0;\n\tif (x == 0) return 1;\n\twhile (x) {\n\t\tres++;\n\t\tx /= 10;\n\t}\n\treturn res;\n}",
		"description": ""
	},
	"Warshall–Floyd": {
		"prefix": "warshall–floyd",
		"body": "rep(k, $1N) rep(i, $1N) rep(j, $1N) {\n\tchmin($2dist[i][j], $2dist[i][k] + $2dist[k][j]);\n}",
	},
	"scanf2": {
		"prefix": "scanf2",
		"body": "scanf(\"%$1d %$1d\", &$2, &$3); // cinに注意",
	},
	"scanf3": {
		"prefix": "scanf3",
		"body": "scanf(\"%$1d %$1d %$1d\", &$2, &$3, &$4); // cinに注意",
	},
	"scanf4": {
		"prefix": "scanf4",
		"body": "scanf(\"%$1d %$1d %$1d %$1d\", &$2, &$3, &$4, &$5); // cinに注意",
	},
	"for (ll i...) for (ll j...)": {
		"prefix": "fij",
		"body": "for (ll i = $1; i < $2N; i++) {\n\tfor (ll j = i+1; j < $2N; j++) {\n\t\t$3\n\t}\n}",
		"description": ""
	},
	"pop_back()": {
		"prefix": "pob",
		"body": "pop_back();",
		"description": ""
	},
	"eps": {
		"prefix": "eps",
		"body": "const double eps = 1e-10;",
		"description": ""
	},
	"atcoder": {
		"prefix": "atcoder",
		"body": "#include <atcoder/all>\nusing namespace atcoder;",
		"description": ""
	},
	"KMP": {
		"prefix": "mp",
		"body": [
			"// Morris-Pratt",
			"template<typename T>",
			"struct MP {",
			"\tll n;",
			"\tT t;",
			"\tvector<ll> a;",
			"\tMP() {}",
			"\tMP(const T& t): t(t) {",
			"\t\tn = t.size();",
			"\t\ta = vector<ll>(n+1);",
			"\t\ta[0] = -1;",
			"\t\tll j = -1;",
			"\t\tfor (ll i = 0; i < n; ++i) {",
			"\t\t\twhile (j != -1 && t[j] != t[i]) j = a[j];",
			"\t\t\tj++;",
			"\t\t\ta[i+1] = j;",
			"\t\t}",
			"\t}",
			"\tll operator[](ll i) { return a[i];}",
			"\tvector<ll> findAll(const T& s) {",
			"\t\tvector<ll> res;",
			"\t\tll j = 0;",
			"\t\tfor (ll i = 0; i < sz(s); ++i) {",
			"\t\t\twhile (j != -1 && t[j] != s[i]) j = a[j];",
			"\t\t\tj++;",
			"\t\t\tif (j == n) {",
			"\t\t\t\tres.push_back(i-j+1);",
			"\t\t\t\tj = a[j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"}; //vector<ll> xa(n), xb(n); 入力後",
			"// MP<vector<ll>> mp(xa); vector<ll> res = mp.findAll(xb);",
			"// xaをどれだけ右にずらしたらxbに一致するか",
			],
	},
	"lazySegmentTree": {
		"prefix": "lazyseg",
		"body": "using mint = $1modint998244353;\n\nstruct S {\n\tmint a;\n\tint size;\n};\n\nstruct F {\n\tmint a, b;\n};\n\nS op(S l, S r) { return S{l.a + r.a, l.size + r.size}; } // datをまとめる\n\nS e() { return S{0, 0}; } // 初期値\n\nS mapping(F l, S r) { return S{r.a * l.a + r.size * l.b, r.size}; } // Ai ←　b * Ai + c の計算\n\nF composition(F l, F r) { return F{r.a * l.a, r.b * l.a + l.b}; } // rが先の演算、lが後の演算で関数を合成\n\nF id() { return F{1, 0}; } // 恒等写像（この関数では値が変わらない）\n// vector<S> a(n); lazy_segtree<S, op, e, F, mapping, composition, id> seg(A);\n// seg.apply(l, r, F{c, d}); seg.prod(l, r).a.val(); // 半開区間",
	},
	"convolution": {
		"prefix": "convolution",
		"body": "convolution$1<998244353>($2, $3);\n",
	},
	"segtreea": {
		"prefix": "segtreea",
		"body": [
			"ll op(ll a, ll b) { return max(a, b); }",
			"",
			"ll e() { return 0; } // 単位元",
			"",
			"// ll target;",
			"// bool f(ll v) { return v < target; }",
			"// seg.max_right<f>(p) // fを満たす最大の値を返す",
			"",
			"// vector<ll> a(100005);",
			"// segtree<ll, op, e> seg(a); // main関数の中で使う",
		],
		"description": "e() は単位元、seg.prod(ll l, ll r)でlからr-1の中で最大値などを返す"
	},
	"struct V": {
		"prefix": "struct V",
		"body": [
			"const double eps = 1e-9;",
			"bool equal(double a, double b) { return abs(a-b) < eps;}",
			"",
			"struct V {",
			"\tdouble x, y;",
			"\tV(double x=0, double y=0): x(x), y(y) {}",
			"\tV& operator+=(const V& v) { x += v.x; y += v.y; return *this;}",
			"\tV operator+(const V& v) const { return V(*this) += v;}",
			"\tV& operator-=(const V& v) { x -= v.x; y -= v.y; return *this;}",
			"\tV operator-(const V& v) const { return V(*this) -= v;}",
			"\tV& operator*=(double s) { x *= s; y *= s; return *this;}",
			"\tV operator*(double s) const { return V(*this) *= s;}",
			"\tV& operator/=(double s) { x /= s; y /= s; return *this;}",
			"\tV operator/(double s) const { return V(*this) /= s;}",
			"\tdouble dot(const V& v) const { return x*v.x + y*v.y;}",
			"\tdouble cross(const V& v) const { return x*v.y - v.x*y;}",
			"\tdouble norm2() const { return x*x + y*y;}",
			"\tdouble norm() const { return sqrt(norm2());}",
			"\tV rotate90() const { return V(y, -x);}",
			"\tll ort() const { // orthant",
			"\t\tif (abs(x) < eps && abs(y) < eps) return 0;",
			"\t\tif (y > 0) return x>0 ? 1 : 2;",
			"\t\telse return x>0 ? 4 : 3;",
			"\t}",
			"\tbool operator<(const V& v) const {",
			"\t\tll o = ort(), vo = v.ort();",
			"\t\tif (o != vo) return o < vo;",
			"\t\treturn cross(v) > 0;",
			"\t}",
			"};",
			"istream& operator>>(istream& is, V& v) {",
			"\tis >> v.x >> v.y; return is;",
			"}",
			"ostream& operator<<(ostream& os, const V& v) {",
			"\tos<<\"(\"<<v.x<<\",\"<<v.y<<\")\"; return os;",
			"}",
		],
		"description": "x-y平面上の点、距離や角度でsortなど"
	},
	"orthant": {
		"prefix": "orthant",
		"body": [
			"// 4つの点を保持",
			"vector<ll> orthant(4);",
			"rep(i, 4) {",
			"\tif (i%3) orthant[i] = LINF;",
			"\telse orthant[i] = -LINF;",
			"}",
			"ll $1N;",
			"cin >> $1N;",
			"vector<pll> XY;",
			"rep(i, $1N) {",
			"\tll x, y;",
			"\tcin >> x >> y;",
			"\tXY.emplace_back(x, y);",
			"\tchmax(orthant[0], x+y);",
			"\tchmin(orthant[1], x-y);",
			"\tchmin(orthant[2], x+y);",
			"\tchmax(orthant[3], x-y);",
			"}",
		],
		"description": "象限"
	},
	"Circle": {
		"prefix": "Circle",
		"body": [
			"struct Circle {",
			"\tV o; double r;",
			"\tCircle(V o=V(), double r=0) : o(o), r(r) {}",
			"\tvector<V> crossPoint(const Circle& c) {",
			"\t\tV v = c.o-o;",
			"\t\tdouble l = v.norm();",
			"\t\tif (equal(l, 0)) return {};",
			"\t\tif (equal(l+r+c.r, max({l,r,c.r})*2)) {",
			"\t\t\tif (equal(l+r,c.r)) return {o - v*(r/l)};",
			"\t\t\treturn {o + v*(r/l)};",
			"\t\t}",
			"\t\tif (l+r+c.r < max({l,r,c.r})*2) return {};",
			"\t\tdouble x = (l*l + r*r - c.r*c.r) / (2*l);",
			"\t\tdouble y = sqrt(r*r - x*x);",
			"\t\tV mid = o + v*(x/l);",
			"\t\tv = v.rotate90();",
			"\t\treturn {mid + v*(y/l), mid - v*(y/l)};",
			"\t}",
			"\tbool isInside(const V& p) const {",
			"\t\treturn (p-o).norm() < r+eps;",
			"\t}",
			"};  // struct V と一緒に使う、auto tmp = a.crossPoint(b); で円aと円bの交点の配列",
			"// a.isInside(p) で 点p が円aに含まれるか判定",
		],
	},
	"dowhile": {
		"prefix": "dowhile",
		"body": [
			"do {",
			"\t$2",
			"} while (next_permutation($1.begin(), $1.end()));",
		],
		"description": ""
	},
	"inversionNumber": {
		"prefix": "inversionNumber",
		"body": [
			"ll inversionNumber(vector<ll> A) {",
			"\t// Aの転倒数、BITfenも必要",
			"\tll res = 0;",
			"\tBIT<ll> bit(N);",
			"\tfor (ll i = 0; i < N; i++) {",
			"\t\tassert(A[i] >= 0);",
			"\t\tres += i - bit.sum(A[i]);",
			"\t\tbit.add(A[i], 1);",
			"\t}",
			"\treturn res;",
			"}",
		],
		"description": "転倒数"
	},
	"digsum": {
		"prefix": "digsum",
		"body": "ll digsum(ll n){ //各桁の和\n\tll a = 0;\n\twhile (n) {\n\t\ta += n%10;\n\t\tn /= 10;\n\t}\n\treturn a;\n}",
		"description": "各桁の和"
	},
	"stack<ll> sk;": {
		"prefix": "sta",
		"body": "stack<$1ll> sk;\n",
	},
	"mergeAandA+x": {
		"prefix": "mergeAandA+x",
		"body": [
			"vector<ll> merge(const vector<ll>& A, ll x) { // merge A and A + x",
			"\tvector<ll> ret;",
			"\tauto it = A.begin();",
			"\tfor(ll a : A) {",
			"\t\twhile(x + *it < a) ret.push_back(x + *it++);",
			"\t\tret.push_back(a);",
			"\t}",
			"\twhile(it < A.end()) ret.push_back(x + *it++);",
			"\treturn ret;",
			"}",
		],
		"description": "merge A and A+x"
	},
	"Pascal's triangle": {
		"prefix": "pascal",
		"body": [
			"// パスカルの三角形",
			"vector<vector<$2ll>> pas($1N+5, vector<$2ll>($1N+5));",
			"pas[0][0] = 1;",
			"for (ll i = 0; i <= $1N; i++) {",
			"\tfor (ll j = 0; j <= i; j++) {",
			"\t\t// if (i) pas[i][j] /= 2; // 確率の時llをdoubleにして",
			"\t\tpas[i+1][j] += pas[i][j];",
			"\t\tpas[i+1][j+1] += pas[i][j];",
			"\t}",
			"}",
		],
	},
	"const ll MX": {
		"prefix": "MX",
		"body": "const ll MX =$1 100005;",
		"description": ""
	},
	"nCr": {
		"prefix": "ncr",
		"body": [
			"ll ncr(ll n, ll r) {",
			"\tr = min(r, n-r);",
			"\tll num, den, g;",
			"\tnum = den = 1;",
			"\twhile (r) {",
			"\t\tnum *= n--;",
			"\t\tden *= r--;",
			"\t\tg = gcd(num, den);",
			"\t\tnum /= g;",
			"\t\tden /= g;",
			"\t}",
			"\treturn num;",
			"}",
		],
	},
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"//{g, x, y}: ax + by = g (mod b でのaの逆元を求められる)",
			"tuple<ll, ll, ll> extgcd(ll a, ll b) {",
			"\tif (b == 0) return {a, 1, 0};",
			"\tauto [g, x, y] = extgcd(b, a%b);",
			"\treturn {g, y, x - (a/b)*y};",
			"}",
		],
	},
	"pow": {
		"prefix": "pow",
		"body": "ll pow(ll a,ll n){ll x=1;for(;n;n/=2)n&1?x=x*a:0,a=a*a;return x;}",
		"description": "power for int & ll",
	},
	"pom": {
		"prefix": "powmod",
		"body": "ll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n",
		"description": "power mod"
	},
	"srand()": {
		"prefix": "srand",
		"body": "srand((unsigned int)time(NULL));",
		"description": "time関数を使った乱数の種の設定, rand()で乱数生成"
	},
	"getTreeDiameter": {
		"prefix": "treediameter",
		"body": [
			"vector<ll> graph[MX];",
			"",
			"pll dfs(ll cur, ll pa = -1) {",
			"\tpll ret = pll(0, cur);  // dist, index",
			"\tfor (ll next : graph[cur]) {",
			"\t\tif (next == pa) continue;",
			"\t\tauto [d, i] = dfs(next, cur);",
			"\t\tif (d+1 > ret.first) ret = pll(d+1, i);",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"ll getTreeDiameter() {",
			"\tauto [d, i] = dfs(0);",
			"\tauto [d2, i2] = dfs(i);",
			"\treturn d2;",
			"}",
		],
		"description": "木の直径"
	},
	"compress": {
		"prefix": "compress",
		"body": [　
			"vector<ll> compress(vector<ll> A) {",
			"\tll n = sz(A);",
			"\tmap<ll, ll> mp;",
			"\trep(i, n) mp[A[i]] = 0;",
			"\tll id = 0;",
			"\tfor (auto& p : mp) p.second = id++;",
			"\trep(i, n) A[i] = mp[A[i]];",
			"\treturn A;",
			"}",
		],
		"description": "座標圧縮"
	},
	"cycle_move": {
		"prefix": "cycle_move",
		"body": [
			"ll cycle_move(ll start, ll k, ll(*func)(ll)) {",
			"\t// 循環する数列のk番目を返す",
			"\tvector<ll> arr;",
			"\tmap<ll, ll> mp;",
			"\tll cur = start, idx = 0;",
			"\twhile (!mp.count(cur)) {",
			"\t\tarr.push_back(cur);",
			"\t\tmp[cur] = idx++;",
			"\t\tcur = func(cur);",
			"\t}",
			"\tif (sz(arr) > k) return arr[k];",
			"\tk -= mp[cur];",
			"\tk %= idx - mp[cur];",
			"\treturn arr[mp[cur] + k];",
			"}",
		],
		"description": "循環する数列のk番目を返す"
	},
	"isinhwcon": {
		"prefix": "isinhwcon",
		"body": "if (!(isin($1ni, 0, $2H) && isin($3nj, 0, $4W))) continue;\n",
		"description": "",
	},
	"LIS": {
		"prefix": "lis",
		"body": [
			"// 最長増加部分列の長さを求める",
			"template<typename T>",
			"ll LIS(vector<T> A) {",
			"\tvector<T> dp(sz(A), INF);",
			"\tfor (ll i = 0; i < sz(A); i++) {",
			"\t\tauto it = lower_bound(dp.begin(), dp.end(), A[i]);",
			"\t\t*it = A[i];",
			"\t}",
			"\treturn lower_bound(dp.begin(), dp.end(), INF) - dp.begin();",
			"}",
		],
		"description": "Longest Increasing Subsequence",
	},
	"all_of": {
		"prefix": "allof",
		"body": "all_of($1.begin(), $1.end(), [&] (ll x) {return x >= $2;})",
	},
	"any_of": {
		"prefix": "anyof",
		"body": "any_of($1.begin(), $1.end(), [&] (ll x) {return x >= $2;})",
	},
	"rotate": {
		"prefix": "rotate",
		"body": [
			"template<typename T>",
			"void rotate(vector<vector<T>>& A) {",
			"\t// rotate 90 degrees clockwise",
			"\tll H = sz(A), W = sz(A[0]);",
			"\tvector pre(W, vector<T>(H));",
			"\tswap(A, pre);",
			"\trep(i, W) rep(j, H) A[i][j] = pre[H-1-j][i];",
			"}",
		],
	},
	"lambda": {
		"prefix": "lambda",
		"body": [
			"auto update = [&] (l i, l j, l d) {",
			"\tif (dist[i][j] != INF) return;",
			"\tdist[i][j] = d;",
			"\tque.emplace(i, j);",
			"};",
		]
	},
	"setsymmetricdiff": {
		"prefix": "setsymmetricdiff",
		"body": "set_symmetric_difference($1.begin(), $1.end(), $2.begin(), $2.end(), back_insert_iterator($3));",
	},
	"Fibonacci": {
		"prefix": "fibonacci",
		"body": [
			"vector<ll> Fibonacci() {",
			"\tll U = 90;",
			"\tvector<ll> ret(U);",
			"\tret[0] = 0; ret[1] = 1;",
			"\tfor (ll i = 2; i < U; i++) {",
			"\t\tret[i] = ret[i-1] + ret[i-2];",
			"\t}",
			"\treturn ret;",
			"}",
		],
		"description": "フィボナッチ数列",
	},
	"dp": {
		"prefix": "dp",
		"body": "$1mint dp[$2][$3];  // dp[i][j] ",
		"description": "",
	},
	"iota": {
		"prefix": "iota",
		"body": "iota($1.begin(), $1.end(), 0);",
	},
	"doubling": {
		"prefix": "doubling",
		"body": [
			"ll coef = $1; // 要検証",
			"for (ll i = $2N; i > 0; i /= 2) {",
			"\tif (i&1) x = x * coef;",
			"\tcoef = coef * coef;",
			"}",
		]
	},
	"cum": {
		"prefix": "cum",
		"body": [
			"auto $1cum = $2A;",
			"for (ll i = 1; i < sz($2A); i++) $1cum[i] += $1cum[i-1];",
			"",
		]
	},
	"cum2": {
		"prefix": "cum2",
		"body": [
			"vector<vector<$1ll>> $2cum($3H+1, vector<$1ll>($4W+1));",
			"rep(i, $3H) rep(j, $4W) {",
			"\t$2cum[i+1][j+1] = $2cum[i][j+1] + $2cum[i+1][j] - $2cum[i][j] + $5A[i][j];",
			"}",
			"",
		]
	},
	"slideMin": {
		"prefix": "slideMin",
		"body": [
			"template <class T>",
			"vector<ll> slideMin(const vector<T>& A, ll k) { ",
			"\tvector<ll> ret;",
			"\tdeque<ll> dq;",
			"\tll n = sz(A);",
			"\tfor (ll i = 0; i < n; ++i) {",
			"\t\twhile (sz(dq) && A[dq.back()] >= A[i]) dq.pop_back();",
			"\t\tdq.push_back(i);",
			"\t\tif (i-k+1 >= 0) {",
			"\t\t\tret.push_back(dq.front());",
			"\t\t\tif (dq.front() <= i-k+1) dq.pop_front();",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"\t// slideMin(vector<ll>{1, 3, 2, 0}, 2) -> {0, 2, 3}",
			"}",
		]
	},
	"bipartite": {
		"prefix": "is_bipartite",
		"body": [
			"ll N; // Nかどうかのチェック",
			"vector<ll> graph[MX];",
			"vector<ll> color(MX, -1);",
			"",
			"bool dfs(ll cur) {",
			"\tfor (ll next : graph[cur]) {",
			"\t\tif (color[next] == color[cur]) return false;",
			"\t\tif (color[next] != -1) continue;",
			"\t\tcolor[next] = color[cur] ^ 1;",
			"\t\tif (dfs(next) == 0) return false;",
			"\t}",
			"\treturn true;",
			"}",
			"",
			"bool is_bipartite() {",
			"\t// 二部グラフなら1を返す",
			"\trep(i, N) {",
			"\t\tif (color[i] != -1) continue;",
			"\t\tcolor[i] = 0;",
			"\t\tif (dfs(i) == 0) return false;",
			"\t}",
			"\treturn true;",
			"}",
		]
	},
}
